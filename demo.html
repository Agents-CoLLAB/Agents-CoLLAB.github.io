<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CoLLAB â€” Personal Assistant (Serverless Demo)</title>
  <meta name="description" content="Serverless demo of CoLLAB personal assistant with 6 agents" />
  <style>
    :root {
      --bg: #0e1117;
      --panel: #141821;
      --muted: #b7c0cc;
      --accent: #5b8cff;
      --accent-2: #7bf0ff;
      --ring-size: 920px; /* fixed canvas for consistent spacing */
      --agent-w: 230px;
      --agent-h: 260px;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background: var(--bg); color: #e8e9ea; }
    a { color: #8ab4ff; text-decoration: none; }
    .layout { display: grid; grid-template-columns: 300px 1fr; gap: 16px; padding: 16px; }
    .sidebar { background: var(--panel); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 14px; position: sticky; top: 12px; height: fit-content; }
    .sidebar h2 { margin: 0 0 8px; font-size: 1.1rem; }
    .sidebar label { display: block; font-size: 0.9rem; color: var(--muted); margin-top: 10px; }
    .sidebar input[type="password"], .sidebar input[type="text"] { width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); background: #0f131a; color: #e8e9ea; }
    .btn { display: inline-block; margin-top: 10px; padding: 10px 12px; font-weight: 700; color: white; border-radius: 10px; background: linear-gradient(135deg, var(--accent), var(--accent-2)); border: none; cursor: pointer; }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }
    .btn.secondary { color: #e8e9ea; font-weight: 700; background: linear-gradient(135deg, var(--accent-2), var(--accent)); box-shadow: 0 10px 24px rgba(91,140,255,0.35); }
    .muted { color: var(--muted); font-size: 0.9rem; }
    .log { margin-top: 12px; height: 260px; overflow-y: auto; background: #0f131a; border: 1px solid rgba(255,255,255,0.08); border-radius: 10px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12.5px; white-space: pre-wrap; }
    .prompt { margin-top: 10px; max-width: 100%; height: 140px; overflow-y: auto; overflow-x: auto; background: #0f131a; border: 1px solid rgba(255,255,255,0.08); border-radius: 10px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12.5px; white-space: pre; color: #cfd6e4; }

    .canvas { position: relative; background: #0f131a; border: 1px solid rgba(255,255,255,0.08); border-radius: 14px; min-height: calc(var(--ring-size) + 120px); overflow: auto; }
    .topbar { position: sticky; top: 0; z-index: 2; display: flex; justify-content: space-between; align-items: center; gap: 12px; padding: 10px 14px; background: rgba(20,24,33,0.9); border-bottom: 1px solid rgba(255,255,255,0.08); }
    .title { font-weight: 800; letter-spacing: 0.3px; }
    .topbar-right { display: flex; gap: 10px; align-items: center; }
    .util { padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1); font-weight: 700; font-size: 0.95rem; }
    .ring { position: relative; width: var(--ring-size); height: var(--ring-size); margin: 24px auto 32px; }
    svg.links { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
    .agent { position: absolute; width: var(--agent-w); height: var(--agent-h); background: var(--panel); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 10px; box-shadow: 0 4px 14px rgba(0,0,0,0.25); z-index: 1; }
    .agent h3 { margin: 0 0 6px; font-size: 1.05rem; }
    .wardrobe { font-size: 0.9rem; line-height: 1.4; max-height: 120px; overflow-y: auto; background: rgba(255,255,255,0.04); padding: 8px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.06); }
    .toggle { display: inline-flex; gap: 6px; margin-top: 6px; }
    .pill { padding: 5px 8px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.2); font-size: 0.8rem; cursor: pointer; user-select: none; }
    .pill.active { background: linear-gradient(135deg, var(--accent), var(--accent-2)); color: #0f131a; border-color: transparent; }
    .prefs { display: flex; gap: 6px; margin-top: 8px; }
    .chip { padding: 4px 8px; border-radius: 999px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.1); font-size: 0.8rem; }
    .agent .footer { position: absolute; left: 8px; right: 8px; bottom: 8px; }

    .legend { display: flex; gap: 12px; align-items: center; }
    .legend .item { display: inline-flex; align-items: center; gap: 6px; padding: 6px 8px; border-radius: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); font-size: 0.9rem; }
    .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; }
  </style>
</head>
<body>
  <div class="layout">
    <aside class="sidebar">
      <h2>Controls</h2>
      <p class="muted">This serverless demo generates a 6â€‘agent personal assistant instance in your browser. The decision step via GPT will use your API key locally (not sent to our servers).</p>
      <label>OpenAI API Key
        <input id="apiKey" type="password" placeholder="sk-..." autocomplete="off" />
      </label>
      <button class="btn" id="btnGenerate">Generate Problem</button>
      <button class="btn" id="btnStepRandom">Run 1 Step (Random)</button>
      <button class="btn secondary" id="btnStep">Run 1 Step (GPT)</button>
      <div class="muted" style="margin-top:10px;">Example GPT prompt:</div>
      <pre class="prompt" id="promptExample"></pre>
      <div id="log" class="log"></div>
    </aside>
    <main class="canvas">
      <div class="topbar">
        <div class="title">CoLLAB Personal Assistant Environment</div>
        <div class="topbar-right">
          <div class="util" id="util">Utility: 0</div>
          <div class="util" id="gptCount">GPT: -</div>
          <div class="legend">
            <span class="item"><span class="dot" style="background:#57d487"></span>Match</span>
            <span class="item"><span class="dot" style="background:#ff6b6b"></span>Not match</span>
            <span class="item"><span class="dot" style="background:#3aa3ff"></span>Disagree</span>
          </div>
        </div>
      </div>
      <div class="ring" id="ring">
        <svg class="links" id="links" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>
        <!-- Agents injected by script -->
      </div>
    </main>
  </div>

  <script>
    const N = 6;
    const AGENT_NAMES = ["Avery","Riley","Jordan","Taylor","Casey","Quinn"];
    const ARTICLES = ["shirt","dress","jacket","blouse","sweater","coat","tâ€‘shirt","hoodie"]; // simple
    const COLORS = ["red","blue","green","yellow","black","white","purple","orange","pink","teal"];

    const state = { agents: [], edges: [], edgePrefs: {}, round: 0, totalGptQueries: 0 };

    function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
    function choice(arr){ return arr[randInt(0,arr.length-1)]; }
    function sample(arr, k){ const s = arr.slice(); const out=[]; while(out.length<k && s.length){ out.push(s.splice(randInt(0,s.length-1),1)[0]); } return out; }

    function generateProblem(){
      state.agents = [];
      state.round = 0;
      // neighbours: i-1, i+1, and opposite (i+3 mod N)
      state.edges = [];
      for(let i=0;i<N;i++){
        const name = AGENT_NAMES[i%AGENT_NAMES.length];
        // wardrobe: 5 items
        const items = [];
        const used = new Set();
        while(items.length<5){
          const a = choice(ARTICLES);
          const c = choice(COLORS);
          const key = a+"|"+c;
          if(used.has(key)) continue;
          used.add(key);
          items.push({ article:a, color:c });
        }
        const prefColors = sample([...new Set(items.map(it=>it.color))], Math.min(2, items.length));
        const choiceIdx = randInt(0, items.length-1);
        state.agents.push({ id:i, name, items, prefColors, choice: choiceIdx });
      }
      for(let i=0;i<N;i++){
        const a=i, b=(i+1)%N, c=(i+N-1)%N, d=(i+3)%N;
        // store undirected unique edges
        for(const [u,v] of [[a,b],[a,c],[a,d]]){
          const key = u<v ? `${u}-${v}` : `${v}-${u}`;
          if(!state.edges.find(e=>e.key===key)) state.edges.push({u:Math.min(u,v), v:Math.max(u,v), key});
        }
      }
      // per-edge endpoint preferences (match/contrast) randomized
      state.edgePrefs = {};
      state.edges.forEach(({u,v,key})=>{
        state.edgePrefs[key] = {
          [`${u}->${v}`]: Math.random()<0.5 ? 'match' : 'contrast',
          [`${v}->${u}`]: Math.random()<0.5 ? 'match' : 'contrast',
        };
      });
      render();
      const util0 = updateUtility();
      resetLog();
      appendLog(state.round, util0);
      state.totalGptQueries = 0;
      setGptCountLabel('GPT queries: - | Total: 0');
      // example prompt
      const ex = buildPromptForAgent?.(0) || '';
      const exBox = document.getElementById('promptExample');
      if (exBox) exBox.textContent = ex;
    }

    function agentPosition(i){
      const ring = document.getElementById('ring');
      const R = ring.getBoundingClientRect();
      const cx = R.width/2, cy = R.height/2;
      const radius = Math.min(R.width,R.height)/2 - 120; // margin
      const theta = (2*Math.PI * i)/N - Math.PI/2; // start at top
      const x = cx + radius * Math.cos(theta);
      const y = cy + radius * Math.sin(theta);
      return { x, y };
    }

    function render(){
      const ring = document.getElementById('ring');
      // clear existing agents
      [...ring.querySelectorAll('.agent')].forEach(n=>n.remove());
      // build agents
      state.agents.forEach((agent,i)=>{
        const el = document.createElement('div');
        el.className = 'agent';
        el.dataset.agent = i;
        const wtxt = agent.items.map((it,idx)=>`#${idx+1} ${it.color} ${it.article}`).join('\n');
        const chosen = agent.items[agent.choice];
        el.innerHTML = `
          <h3>ðŸ‘¤ ${agent.name}</h3>
          <div class="wardrobe">${wtxt}</div>
          <div class="muted" style="margin-top:6px;">Chosen outfit: <strong>#${agent.choice+1} ${chosen.color} ${chosen.article}</strong></div>
          <div class="footer">
            <div class="muted" style="margin-bottom:4px;">Preferred colours</div>
            <div class="prefs">${agent.prefColors.map(c=>`<span class="chip">${c}</span>`).join('')}</div>
          </div>`;
        ring.appendChild(el);
        // place around circle
        const {x,y} = agentPosition(i);
        const rect = { w: el.offsetWidth, h: el.offsetHeight };
        el.style.left = `${x - rect.w/2}px`;
        el.style.top  = `${y - rect.h/2}px`;
      });
      drawLinks();
      updateUtility();
    }

    function centerOf(el){
      const r = el.getBoundingClientRect();
      const parent = document.getElementById('ring').getBoundingClientRect();
      return { x: r.left - parent.left + r.width/2, y: r.top - parent.top + r.height/2 };
    }

    function drawLinks(){
      const svg = document.getElementById('links');
      while(svg.firstChild) svg.removeChild(svg.firstChild);
      const ring = document.getElementById('ring');
      const R = ring.getBoundingClientRect();
      const scaleX = 100 / R.width; const scaleY = 100 / R.height;
      // colors
      const colorMatch = '#57d487';
      const colorContrast = '#ff6b6b';
      const colorDisagree = '#3aa3ff';
      state.edges.forEach(({u,v})=>{
        const a = ring.querySelector(`.agent[data-agent="${u}"]`);
        const b = ring.querySelector(`.agent[data-agent="${v}"]`);
        if(!a||!b) return;
        const ca = centerOf(a), cb = centerOf(b);
        const key = u<v ? `${u}-${v}` : `${v}-${u}`;
        const prefs = state.edgePrefs[key] || {};
        const pu = prefs[`${u}->${v}`] || 'match';
        const pv = prefs[`${v}->${u}`] || 'match';
        let col = colorMatch;
        if (pu === 'match' && pv === 'match') col = colorMatch;
        else if (pu === 'contrast' && pv === 'contrast') col = colorContrast;
        else col = colorDisagree; // disagree

        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', (ca.x*scaleX).toFixed(2));
        line.setAttribute('y1', (ca.y*scaleY).toFixed(2));
        line.setAttribute('x2', (cb.x*scaleX).toFixed(2));
        line.setAttribute('y2', (cb.y*scaleY).toFixed(2));
        line.setAttribute('stroke', col);
        line.setAttribute('stroke-width', '2');
        line.setAttribute('stroke-linecap', 'round');
        svg.appendChild(line);
      });
      updateUtility();
    }

    // --- GPT utilities ---
    function getApiKey(){
      const el = document.getElementById('apiKey');
      return (el && el.value && el.value.trim()) ? el.value.trim() : null;
    }
    function neighboursOf(i){
      const ns = new Set();
      state.edges.forEach(({u,v})=>{ if(u===i) ns.add(v); else if(v===i) ns.add(u); });
      return [...ns];
    }
    function buildPromptForAgent(i){
      const a = state.agents[i];
      const wardrobe = a.items.map((it,idx)=>`  ${idx+1}. ${it.color} ${it.article}`).join('\n');
      const prefs = a.prefColors.join(', ');
      const cons = neighboursOf(i).map(n=>{
        const key = i<n ? `${i}-${n}` : `${n}-${i}`;
        const pref = (state.edgePrefs[key]||{})[`${i}->${n}`] || 'match';
        const nb = state.agents[n];
        const nbChoice = nb.items[nb.choice];
        return `- With ${nb.name}: prefer ${pref} on colour; neighbour currently chose ${nbChoice.color}.`;
      }).join('\n');
      const schema = JSON.stringify({
        type: 'object',
        properties: { choice: { type: 'integer', minimum: 1, maximum: a.items.length } },
        required: ['choice'],
        additionalProperties: false,
      });
      return `You are a personal assistant choosing an outfit for ${a.name}.\n`+
        `Choose exactly one outfit index from 1..${a.items.length}.\n`+
        `Wardrobe:\n${wardrobe}\n`+
        `Personal colour preferences (reward if satisfied): ${prefs || 'none'}.\n`+
        `Neighbour constraints (reward when satisfied):\n${cons || '(none)'}\n`+
        `Output strictly valid JSON per schema with only the field \'choice\'.\n`+
        `JSON Schema: ${schema}`;
    }
    async function gptPickChoice(i){
      const apiKey = getApiKey();
      if(!apiKey) throw new Error('Missing OpenAI API key');
      const prompt = buildPromptForAgent(i);
      const body = {
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: 'You output only valid JSON objects.'},
          { role: 'user', content: prompt }
        ],
        response_format: { type: 'json_object' },
        temperature: 0
      };
      const resp = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify(body)
      });
      if(!resp.ok) throw new Error(`OpenAI HTTP ${resp.status}`);
      const data = await resp.json();
      let text = data?.choices?.[0]?.message?.content?.trim();
      if(!text) throw new Error('Empty completion');
      let obj;
      try { obj = JSON.parse(text); }
      catch(_){
        const s = text.indexOf('{'); const e = text.lastIndexOf('}');
        if(s>=0 && e>s) obj = JSON.parse(text.slice(s,e+1)); else throw new Error('No JSON found');
      }
      const k = Number(obj?.choice);
      if(!Number.isInteger(k)) throw new Error('choice not integer');
      return Math.max(1, Math.min(state.agents[i].items.length, k)) - 1;
    }

    function updateUtility(){
      let total = 0;
      state.edges.forEach(({u,v})=>{
        const key = u<v ? `${u}-${v}` : `${v}-${u}`;
        const prefs = state.edgePrefs[key] || {};
        const uChoice = state.agents[u].items[state.agents[u].choice];
        const vChoice = state.agents[v].items[state.agents[v].choice];
        const pu = prefs[`${u}->${v}`] || 'match';
        const pv = prefs[`${v}->${u}`] || 'match';
        if (pu === 'match') { if (uChoice.color === vChoice.color) total += 1; }
        else { if (uChoice.color !== vChoice.color) total += 1; }
        if (pv === 'match') { if (uChoice.color === vChoice.color) total += 1; }
        else { if (uChoice.color !== vChoice.color) total += 1; }
      });
      state.agents.forEach(a=>{
        const chosen = a.items[a.choice];
        if (a.prefColors.includes(chosen.color)) total += 1;
      });
      const utilEl = document.getElementById('util');
      if (utilEl) utilEl.textContent = `Utility: ${total}`;
      return total;
    }

    function setGptCountLabel(text){
      const el = document.getElementById('gptCount');
      if (el) el.textContent = text;
    }

    function currentAssignmentLines(){
      const lines = [];
      state.agents.forEach(a=>{
        const ch = a.items[a.choice];
        lines.push(`${a.name}: #${a.choice+1} ${ch.color} ${ch.article}`);
      });
      return lines.join("\n");
    }

    function resetLog(){
      const log = document.getElementById('log');
      if (log) log.textContent = '';
    }

    function appendLog(roundNum, util){
      const log = document.getElementById('log');
      if (!log) return;
      const header = `Round ${roundNum}  |  Utility: ${util}`;
      const body = currentAssignmentLines();
      log.textContent += header + "\n" + body + "\n\n";
      log.scrollTop = log.scrollHeight;
    }

    // Controls
    document.getElementById('btnGenerate').addEventListener('click', generateProblem);
    document.getElementById('btnStepRandom')?.addEventListener('click', ()=>{
      state.agents.forEach(a=>{ a.choice = randInt(0, a.items.length-1); });
      state.round += 1;
      render();
      const util = updateUtility();
      appendLog(state.round, util);
      setGptCountLabel(`GPT queries: - | Total: ${state.totalGptQueries}`);
    });
    document.getElementById('btnStep')?.addEventListener('click', async ()=>{
      const apiKey = getApiKey();
      if(!apiKey){ alert('Please enter your OpenAI API key.'); return; }
      const btnR = document.getElementById('btnStepRandom');
      const btnG = document.getElementById('btnStep');
      if(btnR) btnR.disabled = true; if(btnG) btnG.disabled = true;
      try {
        const picks = await Promise.all(state.agents.map((_,i)=>gptPickChoice(i).catch(()=>null)));
        const succ = picks.filter(x=>x!=null).length;
        state.totalGptQueries += state.agents.length;
        state.agents.forEach((a,i)=>{
          if(picks[i] == null){
            // fallback to random on error
            a.choice = randInt(0, a.items.length-1);
          } else {
            a.choice = picks[i];
          }
        });
        state.round += 1;
        render();
        const util = updateUtility();
        appendLog(state.round, util);
        setGptCountLabel(`GPT queries: ${succ}/${state.agents.length} | Total: ${state.totalGptQueries}`);
      } finally {
        if(btnR) btnR.disabled = false; if(btnG) btnG.disabled = false;
      }
    });
    // Placeholder: store key locally (not used yet)
    document.getElementById('apiKey').addEventListener('input', (e)=>{
      try { localStorage.setItem('collab_demo_openai_key', e.target.value || ''); } catch(e){}
    });
    // Restore stored key
    try {
      const saved = localStorage.getItem('collab_demo_openai_key');
      if(saved) document.getElementById('apiKey').value = saved;
    } catch(e){}

    // Initial
    window.addEventListener('resize', ()=>{ render(); });
    generateProblem();
  </script>
</body>
</html>
